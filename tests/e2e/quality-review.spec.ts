import { test, expect } from '@playwright/test';

const EMAIL = process.env.E2E_EMAIL || 'jzineldin@gmail.com';
const PASSWORD = process.env.E2E_PASSWORD || 'Rashzin1996!';

// Locators
const CONTENT_LOCATOR = '.prose .leading-relaxed, .prose .text-foreground';

async function login(page) {
  await page.goto('/');
  const signInNav = page.getByRole('button', { name: /Sign In/i }).first();
  if (await signInNav.count()) {
    await signInNav.click();
  } else {
    await page.goto('/auth');
  }
  await expect(page.locator('form')).toBeVisible({ timeout: 30_000 });
  await page.getByLabel(/Email/i).fill(EMAIL);
  await page.getByLabel(/Password/i).fill(PASSWORD);
  await page.getByRole('button', { name: /Sign In/i }).click();
  await page.waitForURL('**/dashboard', { timeout: 60_000 });
}

async function setLanguageInAgeGenreStep(page, lang: 'en' | 'sv') {
  // Inline language selector in step 1 (compact selector)
  const container = page.locator('[data-testid="wizard-step-age-genre"]');
  const combo = container.getByRole('combobox').first();
  if (await combo.count()) {
    await combo.click();
    const option = lang === 'sv' ? page.getByRole('option', { name: /Svenska/i }) : page.getByRole('option', { name: /English/i });
    if (await option.count()) {
      await option.click();
    } else {
      // Fallback: click by text
      await page.getByText(lang === 'sv' ? /Svenska/i : /English/i).first().click();
    }
  }
}

async function selectAgeGroup(page, age: '7-9' | '10-12') {
  const img = page.locator(`img[alt="Age group ${age}"]`).first();
  await expect(img).toBeVisible({ timeout: 15_000 });
  // Click the parent card
  await img.click({ force: true });
}

async function selectGenre(page, genre: 'Adventure' | 'Fantasy' | 'Mystery') {
  const img = page.locator(`img[alt="Genre ${genre}"]`).first();
  await expect(img).toBeVisible({ timeout: 15_000 });
  await img.click({ force: true });
}

async function clickNext(page) {
  const nextButton = page.getByRole('button', { name: /^(Next|Nästa)$/i });
  await nextButton.click();
}

async function ensureTwoCharacters(page) {
  // Wait for Characters step container
  await expect(page.locator('[data-testid="wizard-step-characters"]')).toBeVisible({ timeout: 30_000 });

  // Wait until loading finishes (Create New button appears)
  await expect(page.getByRole('button', { name: /Create New|Skapa ny/i })).toBeVisible({ timeout: 30_000 });

  const ensureAtLeastTwoCards = async () => {
    for (let i = 0; i < 10; i++) {
      const count = await page.locator('div.cursor-pointer, div[class*="cursor-pointer"]').count();
      if (count >= 2) return true;
      await page.waitForTimeout(500);
    }
    return false;
  };

  // If fewer than 2, create two characters
  if (!(await ensureAtLeastTwoCards())) {
    const createBtn = page.getByRole('button', { name: /Create New|Skapa ny/i });
    for (const [name, type] of [["Friendly Dragon", /dragon/i], ["Brave Knight", /human/i]] as const) {
      await createBtn.click();
      const dialog = page.getByRole('dialog');
      await dialog.getByLabel(/Character Name/i).fill(name);
      await dialog.getByRole('combobox').click();
      await page.getByRole('option', { name: type }).click();
      await dialog.getByLabel(/Description/i).fill('Autogenerated test character.');
      await dialog.getByRole('button', { name: /Create Character/i }).click();
      await page.waitForTimeout(500);
    }
    if (!(await ensureAtLeastTwoCards())) {
      throw new Error('No selectable character cards found');
    }
  }

  // Try to pick by name if present
  const pickByName = async (name: string) => {
    const el = page.getByText(new RegExp(`^${name}$`, 'i')).first();
    if (await el.count()) await el.click();
  };
  await pickByName('Friendly Dragon');
  await pickByName('Brave Knight');

  // If still fewer than 2 selected, click first two cards
  const selectedBadges = page.getByText(/Selected|Vald/i);
  if ((await selectedBadges.count()) < 2) {
    const clickableCards = page.locator('div.cursor-pointer, div[class*="cursor-pointer"]').filter({ hasText: /.+/ });
    const cc = await clickableCards.count();
    if (cc >= 2) {
      await clickableCards.nth(0).click();
      await clickableCards.nth(1).click();
    } else {
      throw new Error('No selectable character cards found');
    }
  }
}

async function openCustomSeedEditor(page) {
  const writeOwnBtn = page.getByRole('button', { name: /(Write (My|Your) Own|Write Your Own Story Idea|Skriv)/i });
  if (await writeOwnBtn.count()) {
    await writeOwnBtn.click();
  } else {
    const customCard = page.getByText(/Write Your Own Story Idea|Custom Story Idea/i).first();
    if (await customCard.count()) await customCard.click();
  }
}

async function waitForContent(page, timeoutMs: number) {
  const start = Date.now();
  const contentLocator = page.locator(CONTENT_LOCATOR);
  await expect(contentLocator).toBeVisible({ timeout: timeoutMs });
  const text = (await contentLocator.innerText()).trim();
  return { text, ms: Date.now() - start };
}

async function extractChoices(page) {
  // Primary: choices with impact line present
  let btns = page.locator('button:has-text("Impact:")');
  let count = await btns.count();
  if (count === 0) {
    // Fallback: look for clustered buttons near content with reasonably long text
    btns = page.locator('button').filter({ hasText: /.{15,}/ });
    count = await btns.count();
  }
  const choices: string[] = [];
  const limit = Math.min(count, 4);
  for (let i = 0; i < limit; i++) {
    const txt = (await btns.nth(i).innerText()).trim();
    if (txt) choices.push(txt.replace(/\s+/g, ' '));
  }
  return choices;
}

function buildSeed(age: string, genre: string, lang: 'en'|'sv', idx: number): string {
  if (lang === 'sv') {
    return `(${age}, ${genre}) Ett kort öppningsäventyr: ${idx} Vänner ger sig ut på ett litet uppdrag med tydlig stämning och enkel början.`;
  }
  return `(${age}, ${genre}) A short opening scenario ${idx}: a gentle setup with clear tone and simple hooks for kids.`;
}

// Grid
const AGE_GROUPS: Array<'7-9'|'10-12'> = ['7-9','10-12'];
const GENRES: Array<'Adventure'|'Fantasy'|'Mystery'> = ['Adventure','Fantasy','Mystery'];

function langForRun(runIndex: number): 'en'|'sv' {
  return runIndex % 2 === 0 ? 'en' : 'sv';
}

test('Quality review: 12-sample grid across age/genre with EN/SV split', async ({ page }) => {
  test.setTimeout(60 * 60 * 1000); // up to 60 minutes for 12 generations

  const consoleErrors: string[] = [];
  page.on('console', (msg) => { if (msg.type() === 'error') consoleErrors.push(`[console.error] ${msg.text()}`); });

  await login(page);

  const results: Array<any> = [];
  let runIndex = 0;

  for (const age of AGE_GROUPS) {
    for (const genre of GENRES) {
      for (let seedIdx = 1; seedIdx <= 2; seedIdx++) {
        const lang = langForRun(runIndex++);
        const sampleId = `${age}-${genre}-seed${seedIdx}-${lang}`;
        try {
          // Navigate and configure
          await page.goto('/create');
          await setLanguageInAgeGenreStep(page, lang);
          await selectAgeGroup(page, age);
          await selectGenre(page, genre);
          await clickNext(page); // Characters

          // Characters: pick first two or create
          await ensureTwoCharacters(page);
          await clickNext(page); // Ideas

          // Seed
          await openCustomSeedEditor(page);
          const seedText = buildSeed(age, genre, lang, seedIdx);
          await page.locator('#custom-seed').fill(seedText);
          await clickNext(page); // Review

          // Create and measure
          const start = Date.now();
          await page.getByRole('button', { name: /Create|Skapa/i }).click();
          const { text, ms } = await waitForContent(page, 120_000);

          // Extract choices
          const choices = await extractChoices(page);
          const uniqueChoices = Array.from(new Set(choices.map(c => c.toLowerCase())));
          const choiceDiversity = uniqueChoices.length >= Math.min(3, choices.length);

          // Language heuristics (best-effort)
          const isLikelySwedish = /[åäöÅÄÖ]|\b(och|det|en|ett|är|med|på|för|som)\b/i.test(text);
          const languageConsistent = lang === 'sv' ? isLikelySwedish : true; // EN can be varied; we check SV more strictly

          results.push({ sampleId, age, genre, lang, ok: true, ms, choices: choices.slice(0,3), choiceDiversity, languageConsistent, textPreview: text.slice(0, 140) });
          console.log(`[QUALITY] ok sample=${sampleId}; ms=${ms}; choices=${choices.length}; diverse=${choiceDiversity}; svConsistent=${languageConsistent}`);
        } catch (e) {
          results.push({ sampleId, age, genre, lang, ok: false, error: String(e) });
          console.warn(`[QUALITY] fail sample=${sampleId}; error=${String(e)}`);
        }
      }
    }
  }

  // Filter actionable errors (similar to main E2E)
  const benignPatterns = /(401)|(row-level security)|(RLS)|(profiles)|(Global error caught)|("error":null)|(subscription-check)|(Failed to send a request to the Edge Function)|(FunctionsFetchError)|(language-fetch)|(TypeError: Failed to fetch)/i;
  const actionableErrors = consoleErrors.filter(e => !benignPatterns.test(e));

  // Aggregate metrics
  const successes = results.filter(r => r.ok);
  const times = successes.map(r => r.ms).sort((a,b)=>a-b);
  const p50 = times[Math.floor(times.length * 0.5)] || null;
  const p90 = times[Math.floor(times.length * 0.9)] || null;
  const p95 = times[Math.floor(times.length * 0.95)] || null;
  const successRate = `${successes.length}/${results.length}`;

  // Emit compact summary for collection
  console.log(`[QUALITY_SUMMARY] successRate=${successRate}; p50=${p50}; p90=${p90}; p95=${p95}; actionableConsoleErrors=${actionableErrors.length}`);

  // Soft assertions: focus on actionable signals
  expect.soft(actionableErrors, 'No actionable console errors during quality review').toHaveLength(0);
  expect.soft(successes.length, 'At least 10 successful generations expected in quality review').toBeGreaterThanOrEqual(10);
});

